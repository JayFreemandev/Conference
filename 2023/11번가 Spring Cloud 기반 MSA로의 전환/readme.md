# 11번가 Spring Cloud 기반 MSA로의 전환

넷플릭스가 만든 Fault Tolerance 

- 장애 전파 방지 & 회복성

기능적 관점에서 본 히스트릭스의 주요 기능 4가지

- 서킷 브레이커
- 폴백
- 쓰레드 고립
- 타임아웃

**히스트릭스 커맨더를 호출할 때 벌어지는 일**

1. 이 메소드를 인터셉트하여 대신 실행한다.
- 쓰레드 고립 : API 호출시 다른 스레드가 나타나서 일을 한다.
1. 메소드의 실행 결과에 성공과 실패 여부를 기록하고 통계를 낸다 통계에 따라 써킷 오픈 여부를 결정한다.
- 서킷 브레이커
1. 실패한 경우(예외) 사용자가 제공한 메소드를 대신 실행한다.
- Fallback : 상품 추천 서버를 호출했는데 반응이없거나 예외가 난다면 고정된 상품 목록을 보여줘서 사용자 경험을 지킴
1. 특정시간 동안 메소드가 종료되지 않는 경우 예외발생
- 타임아웃: 소켓 사용중에 지정한 타임아웃 이전에 연결이 끊길수도 있고, 이 메소드가 어느 시간에 끝날지 모를때가 많아서 서비스 레이어에 걸기 좋음

**서킷 브레이커**

1. 일정 시간동안 일정 개수 호출 → 일정 비율의 에러 발생시 
- Circuit Open(호출 차단)
1. 일정 시간 경과 후에 단 한개의 요청에 대해서 호출을 하용하며 이 호출이 성공한다면 
- Circit Close(호출 허용)

![Untitled](https://github.com/JayFreemandev/Conference/assets/72185011/e5f3c1bd-a1fa-414e-b74c-92c5e6ca8997)


**서킷 브레이커 단위**

한 프로세스 내에서 주어진 커맨드키 단위로 통계를 내고 동작한다.

- 즉, 서킷 브레이커는 커맨드 키 단위로 생성

![Untitled 1](https://github.com/JayFreemandev/Conference/assets/72185011/2c942ad4-72b0-4bc4-a9fe-d24eb220d291)


비지니스 로직을 작성했을때 서킷브레이커를 어떤 단위로 만들것인지가 고민되는 숙제이다.

**Fallback**

Exception이 발생하는 경우 실행 시켜줄 메소드이다.

![Untitled 2](https://github.com/JayFreemandev/Conference/assets/72185011/e5085f31-828d-4345-908f-966e5d6dddba)


추천 서버를 호출시 오류가 나면 recommandFallback 메서드가 호출된다. 하지만 잘못 사용하면 서버 오류를 감추게된다. 실제 11번가 서버 오픈할때 성능테스트시 너무 빠른 속도가 나왔다. 

QA가 끝나고 다음날 로그를 분석하니 맨 앞단 서비스부터 문제가 생겨서 전부 Fallback으로으로 다른 메소드 호출되는 상황이였다. 단 하나의 비지니스로직도 실행되지않고 다른 서버도 호출하지 않았던것이다.

실제 프로덕션에서도 많이 발생한다. 로깅 모니터링을 할텐데 Fallback코드로 인해서 많은 에러코드들이 감춰지기도한다.

HistrixBadReqeusetException을 사용해야하는 순간이 오는데 사용자가 잘못호출한다거나 파라미터를 없이 혹은 NPE 발생시키는 순간에 Fallback을 실행시키지않고 Circuit Open을 위한통계에도 잡히지 않게된다.

즉 메소드 콜러의 실수인경우는 HistrixBadReqeusetException를 Throw하게 작성하는것이 필요하다.

**타임아웃**

실제 적용하고 모든 API가 타임아웃이 나는 상황이 발생했다. 일반적인 API 호출은 1초 이내지만 UI나 무거운 API경우 1초보다 더 걸릴 수 있다. 기본적인 히스트릭스의 타임아웃 기본값은 1초이기 때문이다. 따라서 추가적인 수정이 필요하다.

**고립**

두가지 고립 방식을 서킷 브레이커에서 지정 가능하다

- 세마포어
- 스레드(기본값)

**세마포어**

![Untitled 3](https://github.com/JayFreemandev/Conference/assets/72185011/fd800131-341c-4b5e-86dd-a5e67393b30e)


서킷브레이커 하나를 사용한다는건 그것마다 세마포어가 붙어있다. 어떤 숫자가 정해져있는 값이고 이 이상을 얻을 수 없다. 연동 시스템이 3개가 있을때 뒤 연동 시스템의 최대 동시 호출될 수 있는 개수를 지정할 수 있다.

특정 시스템의 지연이 일어나서 전체 시스템이 지연되는거를 방지하기 위해서다. 이 이상이 요청되면 리젝션이 발생한다. 사용할때 주의할점은 타임아웃이 제대로 발생하지 않는다. 왜?

자바 1.0 시절에는 쓰레드 더 스탑이라는 함수가 있었다. 쓰레드를 남이 멈출 수 있었다. 시스템의 불안전성을 불러일으켜 없어진지 오래됬다. 쓰레드 더 인터럽트를 사용해서 멈추는 방법뿐인데 이것도 사용하는 코드가 해당 인터럽트를 인식하게 작성되어야만 중단시킬 수 있다. 

따라서 넷플릭스 라이브러리에서도 타임아웃하라고 명령을 보내도 복잡하게 돌고 있는 루프의 스레드가 갑자기 리턴되는 방법은 없다. 반대로 기본값으로 제공하는 쓰레드 고립을 사용하면 이런것들이 사라지게된다.

**스레드 고립**

![Untitled 4](https://github.com/JayFreemandev/Conference/assets/72185011/ebb2b998-8717-4794-b18b-2e3491eacc05)


세마포어하는 서킷브레이커 하나당 붙었는데 여기서는 스레드 풀 키라는 이름으로 어느 스레드 풀에서 가라고 지정할 수가 있다. N : 1 관계라 세마포어와 마찬가지로 정해진 요청 이상을 막아주는 장점과 동시에 콜러 스레드와 실제 스레드가 분리되서 특정 시간이 지나게 되면 콜러 스레드는 바로 리턴된다.

아직 진행중인 스레드는 더 돌다 끝나겠지만 사용자에게 응답을 줘야하는 콜러 스레드는 바로 사용자에게 되돌아가게 될것이다. 한가지 주의할점은 **많은 라이브러리들이 스레드 로컬에 의존**하는 경우가 많음

**리본**

![Untitled 5](https://github.com/JayFreemandev/Conference/assets/72185011/4b397080-f0ca-429e-9b8a-01c0176e5763)


한단어로 클라이언트 로드밸런서라고 이야기를 많이하는데 스택오버플로우에 이런 질문들이 많이 올라온다. “저는 리본을 제 서버에 깔아서 쓰는데 왜 클라이언트 로드밸런서인가요?”

즉 말 자체는 API 콜러쪽에 로드 밸런서를 내장한다는 의미이다. 대부분 L4, L7 로드밸런서를 사용할꺼고 사용자 입장에서는 서버 목록을 알지 못한채로 하나의 엔드포인트 하나의 주소만을 알고있다. 

인프라로 하는것들을 어플리케이션 영역에서 직접 서버 목록을 받아 번갈아가며 호출하자는것이다. 즉 인프라 팀의 도움 없이 다수의 서버를 로드 밸런서로 호출하게 된다.

**Spring Cloud에서는 Ribbon 클라이언트를 사용자가 직접 사용하지않음**

- Spring Cloud의 HTTP 통신이 필요한 요소에 내장되어있음
    - Zuul API Gateway
    - Rest Template(@LoadBalanced)
    - Feign(선언적 Http Client)

L4의 도움 없이도 수백대의 서버에 로드밸런서를 실행할 수 있다. 

Rest Template(@LoadBalanced) 어노테이션 하나 붙이면 인터셉터를 통해서 로드밸런서를 끼워놓게된다. IP 어드레스와 포트주소를 지우고 서비스이름만 적으면 알아서 호출하게된다.

리본이 기존의 로드 밸런서와 다른점

우린 L4, L7잘 되있고 아마존 환경이라 ELB, ALB잘쓰고있는데 왜 바꿔야함?

안써도되는데 로드밸런싱이란 개념을 프로그래밍할 수 있다.

**유레카**

![Untitled 6](https://github.com/JayFreemandev/Conference/assets/72185011/7d84731f-27e6-4780-a9a9-fd2d1351081e)


서버 시작시 자연스럽게 나는 살아있고 어떤 서버인지 자동으로 상태 등록하고 주기적으로 하트비트를 보내서 자기가 다운된다면 유레카 서버는 사용하지 못한다고 인지하게된다.

서버를 늘리고 축소할때도 인프라 의존적인 현상을 많이 줄일 수 있음

**API 게이트웨이**

![Untitled 7](https://github.com/JayFreemandev/Conference/assets/72185011/5816a2d2-960d-4dca-8fef-b62ab83931b3)


히스트릭스가 뒷단 서버 장애가 나도 Zuul이 죽지 않게 막아준다.

**서버간 호출 어쩔까**

MSA 외부의 호출은 API GATEWAY를 단일 창구로 사용하지만 플랫폼 내부 서버끼리는 어떻게 할것인가?

![Untitled 8](https://github.com/JayFreemandev/Conference/assets/72185011/276c3979-4d50-4ba5-8d85-6cd55b6e4caa)

왼쪽으로 사용하면 모든 API 호출을 통제시킬 수 있지만 단일 장애 포인트가 게이트웨이가 된다. 게이트웨이가 죽는다는것은 모든 통신이 불가능하다는 의미

오른쪽으로 하는게 맞고 서버끼리 주소는 유레카를 사용해서 호출하기

**Feign**

유레카 없다면 서버 url 명시해주면된다.

![Untitled 9](https://github.com/JayFreemandev/Conference/assets/72185011/f3c8afa5-2796-4641-9329-71a14551207b)


**장애 시나리오**

**특정 API 서버의 인스턴스 하나가 다운되는 경우**

- 유레카에 하트비트 중단됨으로 일정 시간 후 목록에서 사라짐 주의할점은 이 일정시간의 기본값이 상당히 길다는건데 왜냐하면 넷플릭스의 서비스는 수만개이기 때문이다.
- 리본에서 IOEXception 발생한경우 다른 인스턴스로 Retry 한번 한다. 같은 서버를 찌를건지 옆에 서버를 찌를건지 같은 서버를 몇번 찌를건지도 설정이 가능하다.

이런 상황에서 서킷브레이커는 손가락을 빨고있게된다. 서킷은 오픈되지 않고 Fallback과 타임아웃은 동작한다. 서버 3대 기준으로 한대 죽어봐야 에러의 비율은 33%다. 50%가 안된다.

이렇게 3대중 한대가 다운되는거는 유레카와 리본에서 회복성이 구현되는것이지 서킷브레이커가 해줄 일은 별로 없다.

**특정 API가 시간을 너무 오래먹거나 에러인 경우**

- 해당 API를 호출하는 서킷 브레이커 오픈

**모니터링**

- Zipkin + Spring Cloud Sleuth

![Untitled 10](https://github.com/JayFreemandev/Conference/assets/72185011/8826c950-af6c-4212-a834-d3608dded800)

서버간 통신이 적게는 한두개 많게는 다섯 여섯개의 서버를 거쳐서 통신하게 되는데 분산 되어 있어서 만약 수십개가 있다면? 앞단에 API를 호출한 개발자는 뒷단에 무슨 서버를 들리는지 상상할 수 가 없다.

최초의 시작점에서 uuid를 생성하고 그걸 http 헤더에 계속 들고 다니면서 끝까지 연동하면서 로깅으로 남기면 어떤 서버를 거쳐서 실행된건지알 수 있다.

자바에서 @Async나 히스트릭스 쓰면 스레드 변경이 되는데 라이브러리별로 추적이 힘들 수도있다. 다행히도 Spring Cloud Sleuth가 있는데 스프링에서 제공하는 솔루션이다.

- 대부분의 내외부 호출 구간에서 Trace 정보를 생성 및 전달
- Log에 남기거나 수집 서버(Zipkin)에 전송하여 검색/시각화

![Untitled 11](https://github.com/JayFreemandev/Conference/assets/72185011/ef755631-88ea-40c9-bc3c-29291a48cc51)


UUID를 시각화/검색 툴에서 검색해보면 서버가 4대면 1번~4번 서버까지 순차적으로 어떻게 이동했는지 알 수가 있다.

![Untitled 12](https://github.com/JayFreemandev/Conference/assets/72185011/c130da28-de03-42a7-a6e7-718aa77d9553)


들여쓰기가 서버를 호출했다는 순서이다. 각 서버별로 얼마나 지체됬다. 만약 에러가 발생하면 해당 서버는 붉은색으로 표시되고 클릭시 예외까지 보이게된다.

11번가 예시로 새로운 서비스 오픈을 한달 앞두고 API 응답이 너무 느린 상황이 발생함 실제 그 API가 다른 서버의 DB를 1000번 호출하고 있었다. 스트림으로 4줄의 정갈하고 예쁜 코드였고 풀리퀘스트를 통과했기에 문제삼을 여지가 없었으나 해당 api의 파라미터마다 필요한 서버를 호출하다보니 그런 문제가 발생함
